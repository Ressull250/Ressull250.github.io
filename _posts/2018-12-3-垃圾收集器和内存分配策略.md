---
layout:     post
title:      JVM-垃圾收集器和内存分配策略
subtitle:   
date:       2018-12-3
author:     LiaoBo
header-img: img/header_02.jpg
catalog: true
tags:
    - JVM
---

> 图来自网络，文字结合书、笔记整理的


### 3.2 判定对象是否该被回收

- 引用计数算法
  - 引用计数器+1，取消引用-1，但**无法解决循环引用问题**
- 可达性分析算法
  - 以GC Roots为起点顺着**引用链**搜索出所有的活着的对象 
  - GC Roots包括：
    - 虚拟机栈中引用的对象
    - 方法区中类静态属性引用与常量引用的对象
    - 本地方法栈中引用的对象
- 引用分类 
  - 强引用，即普通常见的引用，只要存在其引用对象就不会被回收
  - 软引用，有用但非必需的对象，在抛出内存溢出异常前才会二次回收的对象
  - 弱引用，只能生存到下次回收之前，例如weakhashmap中的键值对
  - 虚引用，完全不管是否有，唯一目的是在回收时会得到一个系统通知
- 两次标记
  - 没有覆盖finalize方法和已经执行过finalize方法的对象会被直接回收
  - 如果有必要执行finalize方法，对象进入F-Queue，执行finalize方法，之后对F-Queue进行二次标记，如果finalize方法中逃逸（比如将this传出去）出来会被移出待回收集合，下次会被直接回收（finalize方法只会被执行一次）。
- 回收方法区
  - 主要是回收**废弃常量**和**无用的类**
  - 无用的类定义：
    - 该类所有实例已经被回收
    - 加载该类的classloader已经被回收
    - 该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法



### 3.3 垃圾收集算法

- 标记-清除算法（Mark-Sweep） 
  - 标记可被回收的，之后回收。效率不高，会有内存碎片。
- 复制算法 
  - 用于新生代的回收
  - 用于对象朝生夕死，一块较大的Eden空间和两块较小的Survivor空间，标记活着的，复制到未使用的Survivor中，无碎片。
- 标记-整理算法 
  - 标记活着的，将活着的整理到空间开头，无碎片。
- 分代收集 
  - 新生代：复制算法
  - 老年代：标记-清除、标记-整理



### 3.4 HotSpot的算法实现

- 枚举根节点：使用准确式GC，减少停顿。
- 安全点：使用安全点保证引用关系变化情况下能安全回收。
- 安全区域：扩展安全点概念为安全区域，应对诸如Thread.sleep()的长时间挂起状态导致无法GC。



### 3.5 垃圾收集器

> 重点学习CMS和G1
> 
> Todo: java8比java7的G1改动

- 概览

![HotspotGC]({{site.url}}/postimgs/HotspotGC.png)

- 新生代
  - Serial：串行收集，单线程，是最早的收集器。
  - ParNew：Serial的多线程版本，多线程收集新生代，可配合CMS使用。
  - Parallel Scavenge：多线程，面向吞吐量，自适应调节策略。
- 老年代
  - Serial Old：Serial的老年代版本，单线程。
  - Parallel Old：Parallel Scavenge的老年代版本，吞吐量优先。
  - **CMS**
- 新生代+老年代：
  - **G1**



- **CMS**（Concurrent Mark Sweep）:

  ![CMS]({{site.url}}/postimgs/CMS.png)

  - 步骤：
    - 初始标记：仅标记GC Roots直接关联的对象，速度很快
    - 并发标记：可以与用户程序并发执行
    - 重新标记：修正因用户程序执行变动的标记
    - 并发清除：清除
  - 缺点：
    - 对CPU资源敏感：与用户进程竞争
    - 无法处理浮动垃圾：标记后产生的垃圾在下一次GC处理；与用户程序并发需预留内存空间，提前GC
    - CMS基于标记-清除算法：内存碎片


- **G1**（Garbage First）：

  - 关于G1：这里有个更细致的[说明](https://zhuanlan.zhihu.com/p/22591838)
  - 特点：
    - 并行并发：利用多CPU、多核优势并发执行
    - 分代收集
    - 空间整合：不会产生内存碎片
    - 可预测停顿：建立可预测的停顿时间模型
  - 说明：
    - G1将java堆内存分为多个独立区域（Region），新生代和老年代不再是物理隔离的
    - 能建立可预测的停顿时间模型是因为：G1跟踪各个Region里面垃圾的价值大小，后台维护优先列表，优先回收价值最大的Region
    - Region之间的对象引用，G1用Remembered Set避免全堆扫描。

  ![G1]({{site.url}}/postimgs/G1.png)

  - 步骤：
    - 初始标记（仅标记GC Roots直接关联的对象）
    - 并发标记
    - 最终标记（修正并发标记期间变动记录）
    - 筛选回收



### 3.6 内存分配与回收策略

> 新生代GC（Minor GC）：
>
> - 指发生在新生代的垃圾收集动作，因为java对象大多数都具有朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。
>
> 老年代GC（Major GC／Full GC）：
>
> - 指发生在老年代的GC，出现了Major GC，经常会伴随至少发生一次的Minor GC（但是并非绝对，在ParallelScavenge收集器的收集策略里，就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。

- **对象优先在Eden分配**
  - 大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。

- **大对象直接进入老年代**
  - 大对象，是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串及数组。大对象对于虚拟机的内存分配来说，是一个坏消息，因为它的经常出现容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。
  - 虚拟机提供了```-XX:PretenureSizeThreshold```参数，让大于这个设置值的对象直接在老年代中分配，这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法来收集内存）。
  - PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，一般也没必要设置。如果遇到必需使用此参数的场合，可以考虑ParNew+CMS的收集器组合*

- **长期存活的对象进入老年代**

  - 虚拟机采用了分代收集的思想来管理内存，那么回收时就必须能够识别哪些对象应当放在新生代，哪些对象应该放在老年代。为了达到这个目的，虚拟机给每个对象定义了一个对象年龄（Age）计数器。
  - 如果对象在Eden出现并经过第一次MinorGC后仍然存活，并且能被Survivor容纳，将被移动到Survivor空间，对象年龄加1。对象在Survivor区每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认值是15）时，就会被晋升到老年代中。

  - *对象晋升老年代的年龄阈值，可以通过参数```-XX:MaxTenuringThreshold```来设置*

- **动态对象年龄判定**

  - 为了能够更好地适应不同程序的内存状况，虚拟机并不是总要求对象的年龄必需达到MaxTenuringThreshold 才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。

- **空间分配担保**

  - 在发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则查看HandlePromotionFailure设置是否允许担保失败；如果允许，那只会进行Minor GC；如果不允许，则也要改为进行一次Full GC。

