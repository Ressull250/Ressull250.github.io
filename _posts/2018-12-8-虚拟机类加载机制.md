---
layout:     post
title:      JVM-类加载机制
subtitle:   
date:       2018-12-8
author:     LiaoBo
header-img: img/header_02.jpg
catalog: true
tags:
    - Java
---
> 这章干货比较多，对类加载机制有了切实的了解
>
> 类加载就是将Class文件信息载入到虚拟机中供使用



### 7.2 类加载时机

- 类的生命周期

  ![类的生命周期]({{site.url}}/postimgs/类的生命周期.jpg)

- 类加载的时机（**当且仅当**以下5种情况）

  - 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有初始化，则需要先出发其初始化。生成这4条指令的典型场景是：使用 ```new``` 关键字实例化对象的时候、读取或设置一个类的静态字段的时候（被final修饰、已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法的时候
  - 使用 ```java.lang.reflect``` 包的方法对类进行反射调用的时候
  - 当初始化一个类时，如果发现它的父类还没有进行初始化，则需要先触发其父类进行初始化
  - 当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的类），虚拟机会先初始化这个类
  - 动态代理中invoke句柄对应类没有初始化



​	

  - Notes:

    以上5种场景是对类的**主动引用**，其他场景对类的引用称为对类的**被动引用**，不会触发类的初始化

    - 通过子类引用父类的静态字段，不会触发子类初始化
    - 通过数组来定义引用类，不会触发引用类的初始化
    - 常量（static final）编译期放入类的常量池，不会触发定义类的初始化



### 7.3 类加载过程

> 加载、验证、准备、解析、初始化

#### 加载

- 通过一个类的全限定名来获取定义这个类对应的二进制字节流
  - 通过**类加载器**
- 将这个类的二进制字节流所代表的静态存储结构转换为方法区的运行时数据结构
- 在Java堆中生成一个代表这个类的 ```java.lang.Class``` 对象，作为方法区这些数据的访问入口



#### 验证

验证是虚拟机对自身保护的一项重要工作，大致完成以下四个阶段的检验过程：

- **文件格式验证**，验证字节流是否符合Class文件格式规范，并且能被当前版本的虚拟机处理。
- **元数据验证**，对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范要求。
- **字节码验证**，主要工作是进行数据流和控制流分析，保证被校验类的方法不会危害到虚拟机的安全。
- **符号引用验证**，可以看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性的校验。



#### 准备

准备阶段是正式**为类变量分配内存**并设置**零值**的阶段，这些内存都将在方法区中进行分配。



#### 解析

解析是虚拟机将常量池中的符号引用替换为直接引用的过程。

- 符号引用
  - 定义在Class文件中的字面量形式，与虚拟机内存布局无关
- 直接引用
  - 直接定位到目标，与内存布局相关。有直接引用那么被引目标一定在虚拟机中



解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点

- 类或接口的解析
- 字段解析
  - 先在类中找，然后按继承递归搜索接口，然后按继承递归搜索父类
  - 在接口和父类中的同名字段会报错
- 类方法解析
  - 先在类中找，然后按继承递归搜索父类，然后按继承递归搜索接口
  - 在接口和父类中的同名方法，父类优先

- 接口方法解析



#### 初始化

真正开始执行类中定义的Java程序代码（或者说是字节码）。

- 初始化阶段执行的是类构造器\<clinit>方法

  \<clinit>方法是由编译期自动搜集类中所有类变量的赋值动作和静态语句块（static块）中语句合并产生的，顺序有语句在源文件中出现的顺序所决定。

- 父类的\<clinit>会优于子类先执行



### 7.4 类加载器

- 定义
  - 类加载过程中的*“通过一个类的全限定名来获取描述这个类的二进制字节流”*这个动作是放在Java虚拟机的外部来实现的，以便于让应用程序自己来决定如何去获取所需要的类，实现这个动作的代码模块被称为**“类加载器”**。

- 判定类相等
  - **类加载器**虽然只用于实现类的加载动作，但是它的作用却远远不限于此，比较两个类是否“相等”，不仅仅要确认这两个类是否来源于同一个class文件，还需要加载这两个类的类加载器相同。



#### 双亲委派模型

  ![双亲委派模型]({{site.url}}/postimgs/双亲委派模型.png)

  - **启动类加载器（Bootstrap ClassLoader）**：负责将存放在 ```<JAVA_HOME>\lib``` 目录中的，或者被 ```-Xbootclasspath``` 参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。
  - **扩展类加载器（Extension ClassLoader）**：负责加载 ```<JAVA_HOME>\lib\ext``` 目录下的，或者被 ```java.ext.dirs``` 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
  - **应用程序类加载器（Application ClassLoader）**：负责加载用户类路径（ClassPath）上所指定的类库，一般情况下这个就是程序中默认的类加载器。



- 解释
  - 要求除了顶层的启动类加载器外，其余的类加载器都必须有自己的父类加载器。（这里类加载器之间的父子关系一般不会以继承（Inheritance）来实现，而是使用组合（Composition）来复用父加载器的代码）。这种模型被广泛使用于几乎所有的Java程序中，但是它并不是一个强制性的约束，只是Java设计者推荐给开发者使用的一种类加载器实现方式。
- 工作过程
  - 如果一个类收到了加载请求，它首先不会尝试自己去加载这个类，而是把这个请求委派给他的父类加载器去完成，每一层次的加载类都是如此，因此所有的加载请求都会传递给最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围内找不到需要加载的类）时，子类才会尝试自己去加载。
- 好处
  - java类随着它的类加载器一起具备了一种带有优先层级的层次关系，保证了Java程序的稳定运行。
  - 处于最顶端的基类（Object类）在各种环境中都是同一个类，保证正确运行
- 如何破坏双亲委托模型
  - 覆盖ClassLoader中的loadClass方法，改为自己实现
- 破坏的实例
  - 基础类需要加载用户代码，而用户代码需要用应用程序加载器加载
  - 解决：线程上下文类加载器

​	
